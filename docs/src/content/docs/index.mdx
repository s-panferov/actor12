---
title: Actor12 Documentation
description: A powerful Rust actor framework with an ergonomic two-step messaging API
template: splash
hero:
  tagline: Concurrent programming made simple and safe
  image:
    file: ../../assets/houston.webp
  actions:
    - text: Get Started
      link: /introduction/
      icon: right-arrow
      variant: primary
    - text: View on GitHub
      link: https://github.com/yourusername/actor12
      icon: external
      variant: minimal
---

import { Card, CardGrid } from '@astrojs/starlight/components';

## What is Actor12?

Actor12 is a modern Rust actor framework that makes concurrent programming intuitive and safe. Built around a unique **two-step messaging API**, it gives you fine-grained control over message handling while maintaining simplicity.

<CardGrid stagger>
  <Card title="🔄 Two-Step API" icon="rocket">
    Send a message, then decide what to do with the response:
    ```rust
    let handle = actor.send_message(msg).await;
    let response = handle.reply().await?;
    ```
  </Card>
  
  <Card title="🎯 Type Safe" icon="approve-check">
    Compile-time guarantees for message types and responses using Rust's powerful type system.
  </Card>
  
  <Card title="🔗 Flexible Messages" icon="puzzle">
    Support for envelope-style, handler-style, and raw message patterns to fit any use case.
  </Card>
  
  <Card title="⚡ High Performance" icon="rocket">
    Built on tokio with efficient async/await patterns and minimal overhead.
  </Card>
</CardGrid>

## Quick Example

Here's a complete counter actor in just a few lines:

```rust
use actor12::{Actor, Handler, Multi, spawn, HandlerMessage};

// Actor with state
pub struct Counter { value: i32 }

// Message types  
pub struct Increment(pub i32);
pub struct GetValue;

// Actor implementation
impl Actor for Counter {
    type Spec = i32;
    type Message = Multi<Self>;
    // ... other required types
}

// Message handlers
impl Handler<Increment> for Counter {
    type Reply = i32;
    async fn handle(&mut self, _ctx: Call<'_, Self, Self::Reply>, msg: Increment) -> Self::Reply {
        self.value += msg.0;
        self.value
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let counter = spawn::<Counter>(0);
    
    // Two-step API: send, then decide
    let handle = counter.send_message(HandlerMessage::new(Increment(5))).await;
    let result = handle.reply().await?;
    
    println!("Counter value: {}", result); // Prints: 5
    Ok(())
}
```

## Ready to Get Started?

<CardGrid>
  <Card title="📚 Learn the Basics" icon="open-book">
    Start with our [Introduction](/introduction/) to understand Actor12's core concepts.
  </Card>
  
  <Card title="⚡ Quick Start" icon="rocket">
    Jump straight into code with our [Quick Start](/quick-start/) guide.
  </Card>
  
  <Card title="🔍 Browse Examples" icon="list-format">
    See real-world patterns in our [Examples](/examples/counter/) section.
  </Card>
  
  <Card title="📖 API Reference" icon="document">
    Dive deep into the [Two-Step API](/api/two-step/) documentation.
  </Card>
</CardGrid>
